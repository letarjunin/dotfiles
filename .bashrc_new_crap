# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

export MAKE=/usr/bin/make
export CXX=/usr/bin/g++
export CC=/usr/bin/gcc
export BOOST_HOME=/home/dbz/pandora/boost-1.48.0-gcc453
export SWIG_COMMAND=/usr/bin/swig
export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64
export CLASSPATH=/opt/JUnit/hamcrest-core-1.3.jar:/opt/JUnit/junit-4.11.jar
export DOXYGEN=/usr/bin/doxygen

#SVN's default editor to vim
export SVN_EDITOR=vim

#adding alias to prune the folders if not part of SVN.
alias prune='svn status --no-ignore | grep '"'^[I?]'"' | cut -c 9- | while IFS= read -r f; do rm -rf "$f"; done'

#svn status without gibberish being thrown on screen.
alias svnstatus="svn status --quiet | grep -v '^\?' | grep -v 'Performing' | grep -v \"^$\""

#Alias tmux
alias tmux='tmux -2'

#set spell check
set spell spelllang=en_us

#Grep search alias
grepSearchWithStype()
{
    echo "${*:2}"
    grep -n -srn --binary-files=without-match --include=*.cpp --include=*.hpp --include=*.h --include=*.cs --include=*.rb --include=*.i --exclude-dir=.svn "${*:2}" . -e "'$1'"
}

alias grepf=grepSearchWithStype

#Adding PB alias
alias pb="~/pb.rb"

#bash_func 
if [ -f ~/.bash_funcs ]; then
    .  ~/.bash_funcs
fi

if [ -f ~/.bash_completion ]; then
    . ~/.bash_completion
fi

#add workflow Script                                                               
#export PATH_TO_WF=$HOME/workflow/lib/workflow.rb                                   
#source $HOME/workflow/workflow.bash         

FULL_PATH=0
export PROMPT_COMMAND=__prompt_command

function _get_user_str {
    local User="\n└>($GREEN\u@\h$NO_COLOR)"
    local SSH_IP=`echo $SSH_CLIENT | awk '{ print $1 }'`
    local SSH2_IP=`echo $SSH2_CLIENT | awk '{ print $1 }'`
    if [ $SSH2_IP ] || [ $SSH_IP ] ; then
        User="\n└>($GREEN\u@$RED\h$NO_COLOR)"
    fi
    echo $User
}

function _get_path_str {
    local Path="($SKY_BLUE\w$NO_COLOR)"
    if [ $FULL_PATH -eq 0 ]
    then
        local depth="$( if [[ ! $PWD =~ .*${HOME}* ]]; then echo NA; exit; fi; 
                    i=0; 
                    while [ \"${PWD}\" != "${HOME}" ]; do 
                        ((i++));
                        cd ../; 
                    done; 
                    if [ $i -gt 0 ]; then echo "$i"; else echo NA; fi; )"
        Path="($SKY_BLUE\W|$depth$NO_COLOR)"
    fi
    echo $PATH
}

#Awesome function to set bash colors.
function __prompt_command {

local err_="$?"

local BLUE="\[\033[1;38;05;27m\]"
local GREEN="\[\033[3;48;05;22m\]"
local ORANGE="\[\033[1;38;05;202m\]"
local PURPLE="\[\033[1;48;05;90m\]"
local CYAN="\[\033[1;38;05;36m\]"
local SKY_BLUE="\[\033[1;38;05;67m\]"
local BLACK="\[\033[1;48;05;8m\]"
local WHITE_BLACK="\[\033[7;48;05;0m\]"
local WHITE="\[\033[1;38;05;7m\]"
local RED="\[\033[3;48;05;1m\]"
local NINE4="\[\033[1;38;05;94m\]"
local NO_COLOR="\[\033[0m\]"

local DATE='$(date "+%a|%b|%d" | xargs )'
local TIME_BLORE='$(export TZ="Asia/Kolkata";date "+%l:%M %p" | xargs )'
local TIME_AUSTIN='$(date "+%l:%M %p" | xargs )'
local Time="┌($WHITE$TIME_AUSTIN$NO_COLOR|$ORANGE$DATE$NO_COLOR|$WHITE$TIME_BLORE$NO_COLOR)-"

local TOTAL_FILES="$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') items,"
local folder_size="$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')"
local Extra="($CYAN$total_files$folder_size$NO_COLOR)-"

local User=$(_get_user_str)
local Path=$(_get_path_str)


local git='$(
             if [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1; then 
                 git_f="$(git config --get remote.origin.url )"; 
                 git_f=${git_f##*/}; 
                 git_f=${git_f%.*}; 
                 git_modif="M$( git ls-files -m | wc -l )";
                 PURPLE="\[\033[1;38;05;90m\]";
                 NO_COLOR="\[\033[0m\]"; 
                 echo "($PURPLE$git_f|$git_modif$NO_COLOR)-"; 
             fi;)'

local gString=""
local cisco="cscotun"
local wlan="wlan"
local eth="eth0"
if [ "$( ifconfig | grep $cisco -A1 )" ]; then
    gString=$cisco
elif [ "$( ifconfig | grep $wlan -A1 )" ]; then
    gString=$wlan
else
    gString=$eth
fi;

local ipaddress="$( ifconfig | grep $gString -A1 | tail -1 | awk '/inet addr/{print substr($2,6)}' )"

ipaddress="($NINE4$ipaddress$NO_COLOR)-"

local job='J$( jobs | echo $( wc -l ) )'
job="($BLUE$job$NO_COLOR)-"

local PREVIOUS_CMD="$( if [ $err_ -eq 0 ]; then echo "$GREEN✔ $NO_COLOR"; else echo "$RED✖ $NO_COLOR"; fi; )"

PS1="$Time$Extra$job$git$ipaddress$Path$User$PREVIOUS_CMD \\$ "
# ♫ ☠

#name - अर्जुन

PS2="$BLUE>$NO_COLOR "
PS4='$BLUE+$NO_COLOR '
}

#for x in 0 1 4 5 7 8; do for i in `seq 30 37`; do for a in `seq 40 47`; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo """]]]"
#for code in {1..255}; do echo -e "\e[38;05;${code}m $code: Test"; done"]"

PATH=$PATH:$HOME/.rvm/bin # Add RVM to PATH for scripting

#RSYCN - 
# sudo rsync --progress -raz --include '*.mp3' dbz@192.168.2.14:/media/dbz/Storage/Arjun/Music .
#rsync --include '*/' --include '*.mp3' --exclude '*'  Music/ myth@192.168.2.6:~/Music/
#Code to get all the colors printed in bash.
#for code in {0..255}; do echo -e "\e[38;05;${code}m $code: Test"; done"]"

alias rsync='rsync -avzul --ignore-existing --stats --progress'
alias mp2='ruby /media/naruto/Storage/Arjun/mplayer-ruby-master/mp2.rb'
alias syn='syndaemon -i 1 -KRd'
alias chr='~/open_chrome_w_touch.rb > /dev/null 2>&1 &'

#shopt -s globstar
#rename 's/\.csv$/.2.csv/' **

PATH=$PATH:/opt/perforce/bin
export P4CONFIG=.p4config
PATH=$PATH:~/Documents/repo/synergy

alias ipa="echo $( ifconfig | awk '/inet addr/{print substr($2,6)}' | grep -v 127.0.0.1 | xargs )"

